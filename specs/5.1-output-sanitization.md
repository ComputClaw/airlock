# Spec 5.1: Output Sanitization (Phase 5 → v0.5.0)

## Goal

All execution output is scanned for credential values before being returned to the agent. Any matches are replaced with `[REDACTED...last4]`. This prevents accidental credential leakage through stdout, stderr, results, or error messages.

**Before:** Execution results are returned as-is from the worker. A script that prints `settings.get("API_KEY")` to stdout leaks the credential.
**After:** All output fields are scanned against the profile's credential values. Matches are redacted before the response reaches the agent. A sanitization log records when redaction occurs.

## Prerequisites

- Spec 2.1 (Credential Management) ✅ — credentials exist and are resolvable
- Spec 3.1 (Profile System) ✅ — profile → credential binding
- Spec 4.1 (Execution Engine) ✅ — execution results flow through SQLite

---

## Architecture

```
Worker returns result
        │
        ▼
┌─────────────────────────┐
│   Sanitization Layer    │
│                         │
│  1. Resolve profile's   │
│     credential values   │
│  2. Scan all output     │
│     fields for matches  │
│  3. Replace matches     │
│     with [REDACTED...]  │
│  4. Log redactions      │
└─────────┬───────────────┘
          │
          ▼
  Update execution in SQLite
  (sanitized output stored)
        │
        ▼
  Return to agent (clean)
```

---

## Tasks

### 1. Sanitizer Module — `src/airlock/sanitizer.py` (new file)

```python
"""Output sanitization: scan and redact credential values from execution output."""

import re
from dataclasses import dataclass


@dataclass
class RedactionEvent:
    """Record of a single redaction."""
    field: str           # stdout | stderr | result | error
    credential_name: str # Which credential was found
    count: int           # How many times it was redacted in this field


def redact_value(text: str, credential_name: str, credential_value: str) -> tuple[str, int]:
    """Replace all occurrences of credential_value in text with redacted form.

    Returns (redacted_text, replacement_count).
    The redacted form is: [REDACTED:{credential_name}...{last4}]
    If the value is 4 chars or shorter, the entire value is masked: [REDACTED:{credential_name}]
    """
    if not credential_value or not text:
        return text, 0

    if len(credential_value) <= 4:
        replacement = f"[REDACTED:{credential_name}]"
    else:
        last4 = credential_value[-4:]
        replacement = f"[REDACTED:{credential_name}...{last4}]"

    # Use literal string replacement (not regex) to handle special chars in values
    count = text.count(credential_value)
    if count > 0:
        text = text.replace(credential_value, replacement)
    return text, count


def sanitize_output(
    stdout: str,
    stderr: str,
    result_json: str | None,
    error: str | None,
    credentials: dict[str, str],
) -> tuple[str, str, str | None, str | None, list[RedactionEvent]]:
    """Sanitize all output fields against credential values.

    Args:
        stdout: Worker stdout
        stderr: Worker stderr
        result_json: JSON-encoded result string (or None)
        error: Error message (or None)
        credentials: {name: plaintext_value} dict for the profile

    Returns:
        (sanitized_stdout, sanitized_stderr, sanitized_result, sanitized_error, redaction_log)
    """
    redactions: list[RedactionEvent] = []

    for cred_name, cred_value in credentials.items():
        if not cred_value:
            continue

        for field_name, field_value in [
            ("stdout", stdout),
            ("stderr", stderr),
            ("result", result_json),
            ("error", error),
        ]:
            if field_value is None:
                continue
            _, count = redact_value(field_value, cred_name, cred_value)
            if count > 0:
                redactions.append(RedactionEvent(
                    field=field_name, credential_name=cred_name, count=count
                ))

    # Apply redactions (do this after counting to avoid cross-contamination)
    for cred_name, cred_value in credentials.items():
        if not cred_value:
            continue
        stdout, _ = redact_value(stdout, cred_name, cred_value)
        stderr, _ = redact_value(stderr, cred_name, cred_value)
        if result_json is not None:
            result_json, _ = redact_value(result_json, cred_name, cred_value)
        if error is not None:
            error, _ = redact_value(error, cred_name, cred_value)

    return stdout, stderr, result_json, error, redactions
```

### 2. Wire Sanitization into Execution Dispatch — Update `src/airlock/api/agent.py`

Update `_dispatch_to_worker` to sanitize output before persisting:

```python
async def _dispatch_to_worker(
    db: aiosqlite.Connection,
    worker: WorkerManager,
    execution_id: str,
    script: str,
    settings: dict[str, str],
    timeout: int,
) -> None:
    """Send script to Docker worker, sanitize output, persist results."""
    await update_execution(db, execution_id, status="running")

    start = time.monotonic()
    try:
        result = await worker.execute(script, settings, timeout)
        elapsed_ms = int((time.monotonic() - start) * 1000)

        # Sanitize output before persisting
        raw_result_json = json.dumps(result.get("result")) if result.get("result") is not None else None
        stdout, stderr, result_json, error, redactions = sanitize_output(
            stdout=result.get("stdout", ""),
            stderr=result.get("stderr", ""),
            result_json=raw_result_json,
            error=result.get("error"),
            credentials=settings,
        )

        # Parse result back from JSON if it was sanitized
        sanitized_result = json.loads(result_json) if result_json is not None else None

        await update_execution(
            db, execution_id,
            status=result["status"],
            result=sanitized_result,
            stdout=stdout,
            stderr=stderr,
            error=error,
            execution_time_ms=elapsed_ms,
        )

        # Log redactions if any occurred
        if redactions:
            logger.warning(
                f"Execution {execution_id}: redacted {len(redactions)} credential(s) from output"
            )

    except Exception as e:
        elapsed_ms = int((time.monotonic() - start) * 1000)
        await update_execution(
            db, execution_id,
            status="error",
            error=str(e),
            execution_time_ms=elapsed_ms,
        )
```

### 3. Add Redaction Log to Executions Table — Update `src/airlock/db.py`

Add a `redactions` column to store sanitization events:

```sql
ALTER TABLE executions ADD COLUMN redactions TEXT;  -- JSON array of redaction events
```

Add to MIGRATIONS list and update SCHEMA for fresh databases.

### 4. Update Execution Service — `src/airlock/services/executions.py`

- Add `redactions` parameter to `update_execution()`
- Include `redactions` in `get_execution()` and `list_executions()` responses
- Store as JSON text in SQLite

### 5. Expose Redactions in Admin API

Admin execution detail should show redaction log:

```json
GET /api/admin/executions/{id}
{
  "execution_id": "exec_...",
  "status": "completed",
  "result": {"data": "[REDACTED:API_KEY...b123]"},
  "stdout": "Fetched with [REDACTED:API_KEY...b123]",
  "redactions": [
    {"field": "stdout", "credential_name": "API_KEY", "count": 1},
    {"field": "result", "credential_name": "API_KEY", "count": 1}
  ]
}
```

Agent-facing `GET /executions/{id}` does NOT include redactions — agents shouldn't know which credentials triggered redaction.

---

## What Does NOT Change

- Worker container — unchanged, returns raw output
- Credential system — unchanged
- Profile system — unchanged
- LLM pause/resume — unchanged

## What This Enables

After this spec:
- Credentials never leak through execution output
- Admins can see exactly which credentials were redacted and where
- The sanitization layer sits between worker and storage, so persisted data is always clean
- Future: network sanitization could build on the same pattern

---

## Tests

### Unit Tests — `tests/test_sanitization.py` (new file)

#### Sanitizer Core
- `redact_value` with credential in text → replaced with `[REDACTED:NAME...last4]`
- `redact_value` with short credential (≤4 chars) → `[REDACTED:NAME]` (no last4)
- `redact_value` with no match → text unchanged, count=0
- `redact_value` with empty text → unchanged
- `redact_value` with empty credential value → unchanged
- `redact_value` with multiple occurrences → all replaced, correct count
- `redact_value` with special regex chars in value (e.g., `$`, `.`, `+`) → handled correctly

#### sanitize_output
- Credential in stdout → redacted, RedactionEvent logged
- Credential in stderr → redacted, RedactionEvent logged
- Credential in result JSON → redacted, RedactionEvent logged
- Credential in error → redacted, RedactionEvent logged
- Multiple credentials → all scanned, all redacted
- Credential not present → no redactions, output unchanged
- None fields (no result, no error) → handled without crash
- Credential that's a substring of another credential → both handled correctly

#### Integration (with execution flow)
- Execute script that prints credential → GET result shows `[REDACTED...]`
- Execute script that returns credential in `set_result()` → result redacted
- Execute script that raises error containing credential → error redacted
- Redaction log stored in SQLite → visible in admin API
- Agent execution detail does NOT include redactions field

### Existing Tests
- All 147 existing tests must pass
- Execution engine tests may need minor updates if response shape changes

---

## Implementation Order

1. `src/airlock/sanitizer.py` — sanitizer module
2. Update `src/airlock/db.py` — add `redactions` column + migration
3. Update `src/airlock/services/executions.py` — add redactions to CRUD
4. Update `src/airlock/api/agent.py` — wire sanitization into `_dispatch_to_worker`
5. Update `src/airlock/api/admin.py` — expose redactions in admin detail
6. `tests/test_sanitization.py` — all tests
7. Verify all existing tests pass

---

## Acceptance Criteria

- [ ] Credential values in stdout are replaced with `[REDACTED:NAME...last4]`
- [ ] Credential values in stderr are redacted
- [ ] Credential values in result JSON are redacted
- [ ] Credential values in error messages are redacted
- [ ] Short credentials (≤4 chars) show `[REDACTED:NAME]` without last4
- [ ] Special characters in credential values don't break scanning
- [ ] Redaction events logged in `redactions` column (JSON)
- [ ] Admin API shows redaction log
- [ ] Agent API does NOT show redaction log
- [ ] Sanitization runs before SQLite persistence (stored data is clean)
- [ ] All new tests pass
- [ ] All existing tests pass

---

## Notes for CC

- Use plain string `.replace()`, not regex — credential values may contain regex special chars.
- Sanitization happens in `_dispatch_to_worker` (agent.py), after the worker returns but before `update_execution`.
- The `credentials` dict (settings) is already resolved and available in `_dispatch_to_worker` — pass it to `sanitize_output`.
- The result comes from the worker as a Python object. Serialize to JSON string before scanning, then deserialize back after. This catches credentials embedded in nested JSON structures.
- `redactions` column is nullable TEXT (JSON). NULL when no redactions occurred.
- For the counting step, scan all fields first, then apply replacements. This avoids a replacement in one field affecting the count in another (e.g., if the redacted form of one credential matches another credential's value — unlikely but defensive).
